
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>COFF Loader Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-collapsible-chapters/collapsible-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Elastic EDR.html" />
    
    
    <link rel="prev" href="Docs/Passing arguments.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <a target="_blank" href="https://twitter.com/HackerOtter">
            
                    
                    Follow On Twitter
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    Formation
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" >
            
                <span>
            
                    
                    Malware Development
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1.1" data-path="../Formation/RTO - Malware Development/0 - Introduction.html">
            
                <a href="../Formation/RTO - Malware Development/0 - Introduction.html">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.1.2" data-path="../Formation/RTO - Malware Development/1 - PE.html">
            
                <a href="../Formation/RTO - Malware Development/1 - PE.html">
            
                    
                    PE
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.1.3" data-path="../Formation/RTO - Malware Development/2 - Payload Storage.html">
            
                <a href="../Formation/RTO - Malware Development/2 - Payload Storage.html">
            
                    
                    Payload Storage
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.1.4" data-path="../Formation/RTO - Malware Development/3 - Payload Encryption.html">
            
                <a href="../Formation/RTO - Malware Development/3 - Payload Encryption.html">
            
                    
                    Payload Encryption
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.1.5" data-path="../Formation/RTO - Malware Development/4 - Function Call Obfuscation.html">
            
                <a href="../Formation/RTO - Malware Development/4 - Function Call Obfuscation.html">
            
                    
                    Function Call Obfuscation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.1.6" data-path="../Formation/RTO - Malware Development/5 - Backdooring PE.html">
            
                <a href="../Formation/RTO - Malware Development/5 - Backdooring PE.html">
            
                    
                    Backdooring PE
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" >
            
                <span>
            
                    
                    Malware
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" >
            
                <span>
            
                    
                    Docs
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1.1" data-path="Docs/Code snippet.html">
            
                <a href="Docs/Code snippet.html">
            
                    
                    Code Snippet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.1.2" data-path="Docs/Dumpbin.html">
            
                <a href="Docs/Dumpbin.html">
            
                    
                    Dumpbin
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.1.3" data-path="Docs/NTStructure.html">
            
                <a href="Docs/NTStructure.html">
            
                    
                    NTStructure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.1.4" data-path="Docs/Passing arguments.html">
            
                <a href="Docs/Passing arguments.html">
            
                    
                    Passing Arguments
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter active" data-level="3.1.2" data-path="CoffLoader.html">
            
                <a href="CoffLoader.html">
            
                    
                    COFF Loader
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="Elastic EDR.html">
            
                <a href="Elastic EDR.html">
            
                    
                    Elastic EDR
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="ETW.html">
            
                <a href="ETW.html">
            
                    
                    ETW
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="Function hooking.html">
            
                <a href="Function hooking.html">
            
                    
                    Function Hooking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.6" data-path="Kernel callback.html">
            
                <a href="Kernel callback.html">
            
                    
                    Kernel Callback
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.7" data-path="Module stomping.html">
            
                <a href="Module stomping.html">
            
                    
                    Module Stomping
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.8" data-path="Reflective DLL injection.html">
            
                <a href="Reflective DLL injection.html">
            
                    
                    Reflective DLL Injection
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" >
            
                <span>
            
                    
                    Pentest
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" >
            
                <span>
            
                    
                    Cloud
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1.1" data-path="../Pentest/Cloud/Azure.html">
            
                <a href="../Pentest/Cloud/Azure.html">
            
                    
                    Azure
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.1.2" >
            
                <span>
            
                    
                    Configuration Review
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.2.1" data-path="../Pentest/Configuration review/Database.html">
            
                <a href="../Pentest/Configuration review/Database.html">
            
                    
                    Database
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2.2" data-path="../Pentest/Configuration review/Kubernetes.html">
            
                <a href="../Pentest/Configuration review/Kubernetes.html">
            
                    
                    Kubernetes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2.3" data-path="../Pentest/Configuration review/KubernetesCIS.html">
            
                <a href="../Pentest/Configuration review/KubernetesCIS.html">
            
                    
                    KubernetesCIS
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.1.3" >
            
                <span>
            
                    
                    Services
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.3.1" data-path="../Pentest/Services/AD.html">
            
                <a href="../Pentest/Services/AD.html">
            
                    
                    AD
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.2" data-path="../Pentest/Services/DNS.html">
            
                <a href="../Pentest/Services/DNS.html">
            
                    
                    DNS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.3" data-path="../Pentest/Services/IPMI.html">
            
                <a href="../Pentest/Services/IPMI.html">
            
                    
                    IPMI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.4" data-path="../Pentest/Services/Kerberos.html">
            
                <a href="../Pentest/Services/Kerberos.html">
            
                    
                    Kerberos
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.5" data-path="../Pentest/Services/LDAP.html">
            
                <a href="../Pentest/Services/LDAP.html">
            
                    
                    LDAP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.6" data-path="../Pentest/Services/Memcached.html">
            
                <a href="../Pentest/Services/Memcached.html">
            
                    
                    Memcached
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.7" data-path="../Pentest/Services/NFS.html">
            
                <a href="../Pentest/Services/NFS.html">
            
                    
                    NFS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.8" data-path="../Pentest/Services/Oracle database.html">
            
                <a href="../Pentest/Services/Oracle database.html">
            
                    
                    Oracle Database
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.9" data-path="../Pentest/Services/MSSQL.html">
            
                <a href="../Pentest/Services/MSSQL.html">
            
                    
                    MSSQL
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.10" data-path="../Pentest/Services/RPC.html">
            
                <a href="../Pentest/Services/RPC.html">
            
                    
                    RPC
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.11" data-path="../Pentest/Services/SMB.html">
            
                <a href="../Pentest/Services/SMB.html">
            
                    
                    SMB
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.12" data-path="../Pentest/Services/SNMP.html">
            
                <a href="../Pentest/Services/SNMP.html">
            
                    
                    SNMP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.13" data-path="../Pentest/Services/Tomcat.html">
            
                <a href="../Pentest/Services/Tomcat.html">
            
                    
                    Tomcat
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3.14" data-path="../Pentest/Services/WebDAV.html">
            
                <a href="../Pentest/Services/WebDAV.html">
            
                    
                    WebDAV
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.1.4" >
            
                <span>
            
                    
                    Techniques
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.4.1" data-path="../Pentest/Techniques/Abuse tokens.html">
            
                <a href="../Pentest/Techniques/Abuse tokens.html">
            
                    
                    Abuse Tokens
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.2" data-path="../Pentest/Techniques/Buffer overflow.html">
            
                <a href="../Pentest/Techniques/Buffer overflow.html">
            
                    
                    Buffer Overflow
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.3" data-path="../Pentest/Techniques/Command injection.html">
            
                <a href="../Pentest/Techniques/Command injection.html">
            
                    
                    Command Injection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.4" data-path="../Pentest/Techniques/Data exfiltration.html">
            
                <a href="../Pentest/Techniques/Data exfiltration.html">
            
                    
                    Data Exfiltration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.5" data-path="../Pentest/Techniques/Exploit handles.html">
            
                <a href="../Pentest/Techniques/Exploit handles.html">
            
                    
                    Exploit handles
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.6" data-path="../Pentest/Techniques/Filtering.html">
            
                <a href="../Pentest/Techniques/Filtering.html">
            
                    
                    Filtering
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.7" data-path="../Pentest/Techniques/Kioske escape.html">
            
                <a href="../Pentest/Techniques/Kioske escape.html">
            
                    
                    Kioske Escape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.8" data-path="../Pentest/Techniques/LFI.html">
            
                <a href="../Pentest/Techniques/LFI.html">
            
                    
                    LFI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.9" data-path="../Pentest/Techniques/Password spraying.html">
            
                <a href="../Pentest/Techniques/Password spraying.html">
            
                    
                    Password Spraying
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.10" data-path="../Pentest/Techniques/Pivoting.html">
            
                <a href="../Pentest/Techniques/Pivoting.html">
            
                    
                    Pivoting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.11" >
            
                <span>
            
                    
                    Privilege Escalation
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.4.11.1" data-path="../Pentest/Techniques/Privileges escalation/Windows.html">
            
                <a href="../Pentest/Techniques/Privileges escalation/Windows.html">
            
                    
                    Windows
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.11.2" data-path="../Pentest/Techniques/Privileges escalation/Linux.html">
            
                <a href="../Pentest/Techniques/Privileges escalation/Linux.html">
            
                    
                    Linux
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.1.4.12" data-path="../Pentest/Techniques/Reverse shell.html">
            
                <a href="../Pentest/Techniques/Reverse shell.html">
            
                    
                    Reverse Shell
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.13" data-path="../Pentest/Techniques/Shellshock.html">
            
                <a href="../Pentest/Techniques/Shellshock.html">
            
                    
                    Shellshock
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.14" data-path="../Pentest/Techniques/SQL injection.html">
            
                <a href="../Pentest/Techniques/SQL injection.html">
            
                    
                    SQL Injection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4.15" data-path="../Pentest/Techniques/SSTI.html">
            
                <a href="../Pentest/Techniques/SSTI.html">
            
                    
                    SSTI
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.1.5" >
            
                <span>
            
                    
                    Technology
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.5.1" data-path="../Pentest/Technology/AD.html">
            
                <a href="../Pentest/Technology/AD.html">
            
                    
                    AD
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5.2" data-path="../Pentest/Technology/IOS.html">
            
                <a href="../Pentest/Technology/IOS.html">
            
                    
                    IOS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5.3" data-path="../Pentest/Technology/NAC.html">
            
                <a href="../Pentest/Technology/NAC.html">
            
                    
                    NAC
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5.4" data-path="../Pentest/Technology/Port Knocking.html">
            
                <a href="../Pentest/Technology/Port Knocking.html">
            
                    
                    Port Knocking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5.5" data-path="../Pentest/Technology/SAML.html">
            
                <a href="../Pentest/Technology/SAML.html">
            
                    
                    SAML
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5.6" data-path="../Pentest/Technology/SAP.html">
            
                <a href="../Pentest/Technology/SAP.html">
            
                    
                    SAP
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.1.6" >
            
                <span>
            
                    
                    Tools
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.6.1" data-path="../Pentest/Tools/BloundHound.html">
            
                <a href="../Pentest/Tools/BloundHound.html">
            
                    
                    BloundHound
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.2" data-path="../Pentest/Tools/CME.html">
            
                <a href="../Pentest/Tools/CME.html">
            
                    
                    CME
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.3" data-path="../Pentest/Tools/Curl.html">
            
                <a href="../Pentest/Tools/Curl.html">
            
                    
                    Curl
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.4" data-path="../Pentest/Tools/Ffuf.html">
            
                <a href="../Pentest/Tools/Ffuf.html">
            
                    
                    FFUF
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.5" data-path="../Pentest/Tools/Find.html">
            
                <a href="../Pentest/Tools/Find.html">
            
                    
                    Find
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.6" data-path="../Pentest/Tools/Hydra.html">
            
                <a href="../Pentest/Tools/Hydra.html">
            
                    
                    Hydra
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.7" data-path="../Pentest/Tools/PowerView.html">
            
                <a href="../Pentest/Tools/PowerView.html">
            
                    
                    PowerView
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.8" data-path="../Pentest/Tools/Powershell.html">
            
                <a href="../Pentest/Tools/Powershell.html">
            
                    
                    Powershell
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.9" data-path="../Pentest/Tools/Responder.html">
            
                <a href="../Pentest/Tools/Responder.html">
            
                    
                    Responder
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.10" data-path="../Pentest/Tools/Rubeus.html">
            
                <a href="../Pentest/Tools/Rubeus.html">
            
                    
                    Rubeus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.11" data-path="../Pentest/Tools/Strace.html">
            
                <a href="../Pentest/Tools/Strace.html">
            
                    
                    Strace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.6.12" data-path="../Pentest/Tools/Wfuzz.html">
            
                <a href="../Pentest/Tools/Wfuzz.html">
            
                    
                    Wfuzz
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" >
            
                <span>
            
                    
                    Rainy Sunday
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1.1" data-path="../Serveur/KMS/KMS.html">
            
                <a href="../Serveur/KMS/KMS.html">
            
                    
                    KMS Activation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.2" data-path="../Serveur/LicenceKey.html">
            
                <a href="../Serveur/LicenceKey.html">
            
                    
                    Licence Key
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >COFF Loader</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="coffloader">CoffLoader</h1>
<!-- toc -->
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#portable-executable-pe">Portable Executable (PE)</a><ul>
<li><a href="#store-data-in-a-pe">Store data in a PE</a></li>
<li><a href="#reference-to-functions-and-variables-during-execution">Reference to functions and variables during execution</a></li>
</ul>
</li>
<li><a href="#object-files">Object files</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#coff-loader">Coff Loader</a><ul>
<li><a href="#bof-or-coff-">BOF or COFF ?</a></li>
<li><a href="#bof-advantages">BOF advantages</a></li>
<li><a href="#bof-disadvantage">BOF disadvantage</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#hands-on--coff-loader">Hands on : COFF Loader</a><ul>
<li><a href="#blueprint">Blueprint</a></li>
<li><a href="#coff-specification">COFF specification</a><ul>
<li><a href="#coff-header">COFF Header</a></li>
<li><a href="#sections-header">Sections Header</a></li>
<li><a href="#navigate-into-sections">Navigate into sections</a></li>
<li><a href="#relocations-table">Relocations Table</a></li>
<li><a href="#absolute-and-relative-address">Absolute and Relative address</a></li>
<li><a href="#symbol-table">Symbol Table</a></li>
<li><a href="#symbol-table-string">Symbol Table String</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li><a href="#write-sections-in-memory">Write sections in memory</a></li>
<li><a href="#perform-relocations">Perform relocations</a><ul>
<li><a href="#special-symbol">Special symbol</a></li>
<li><a href="#standard-symbol-relocation">Standard symbol relocation</a></li>
<li><a href="#put-things-altogether">Put things altogether</a></li>
</ul>
</li>
<li><a href="#run-the-code">Run the code</a></li>
</ul>
</li>
<li><a href="#upgrade">Upgrade</a><ul>
<li><a href="#compatibility-with-cobaltstrike-bof">Compatibility with CobaltStrike BOF</a><ul>
<li><a href="#cobaltstrike-bof-specificities">CobaltStrike BOF specificities</a></li>
<li><a href="#add-support-for-beacon-internal-functions">Add support for beacon internal functions</a></li>
<li><a href="#format-parameters-for-cobalstrike-bof">Format parameters for CobalStrike BOF</a></li>
</ul>
</li>
<li><a href="#dynamic-got-and-bss">Dynamic .got and .bss</a></li>
</ul>
</li>
<li><a href="#conclusion-2">Conclusion</a></li>
<li><a href="#ressources">Ressources</a></li>
</ul>
<!-- tocstop -->
<h1 id="introduction">Introduction</h1>
<p><code>COFF</code> stands for Common Object Files.</p>
<p>The <code>COFF</code> format is initially used for <code>Linux ELF</code> executables but is now used by <code>Microsoft</code> for many years now.</p>
<p>For example, the <code>Windows</code> executable, also known as <code>PE</code> are formatted following the <code>COFF</code> format. Likewise, the object files generated during compilation and the shared libraries follows the same format.</p>
<p>The goal of this article is to dive into the <code>COFF</code> format to understand how it can describe a full executable file. Then, the <code>Windows</code> object files will be analyzed to finally lead to the development <code>COFF Loader</code>: a program that can run a <code>Windows</code> object file in memory.</p>
<p>A <code>COFF Loader</code> is a program taking as input an <code>Windows</code> object file and execute it as a standard executable file. This technic is often used by malware as the program will only exist in memory, limiting the malware footprint. Moreover, because the program is fully executed in memory, it will be harder for detection solutions such as <code>anti-virus</code> or <code>EDR</code> to detect it and prevent its execution.</p>
<h1 id="portable-executable-pe">Portable Executable (PE)</h1>
<h2 id="store-data-in-a-pe">Store data in a PE</h2>
<p><code>PE</code> is a format used by the <code>Windows</code> executable.</p>
<pre><code class="lang-bash">&#x250C;&#x2500;&#x2500;(pikachu&#x327F;Kali)-[~/Share]
&#x2514;&#x2500;$ file windowsExecutable.exe 
windowsExecutable.exe: PE32+ executable (console) x86-64, <span class="hljs-keyword">for</span> MS Windows
</code></pre>
<p>The <code>PE</code> is structured as a book. Indeed, the <code>PE</code> has a global header that contains information about itself such as a book cover and all the data is organized in chapters called sections. All sections get their own header. </p>
<p>Each section goal is different and they are used to organize all the data needed for the program proper functioning.</p>
<p><code>PE</code> files can be inspected through several tools such as <a href="https://ntcore.com/?page_id=345" target="_blank">CFFExplorer</a>.</p>
<p><img src="img/CoffLoader/PE/CFFExplorer.jpg" alt="PE opened in CFFExplorer"></p>
<p>As it is shown in the previous figure, the <code>PE</code> is organized in different sections:</p>
<ul>
<li><code>.text</code> : this section is used to store the executable code.</li>
<li><code>.bss</code> : this section is used to store any uninitialized global variable. Thus, if you use the statement <code>int a;</code> outside of any function or module, this variable will likely be stored in the <code>.bss</code> section. As all data are uintialized, this section is always empty. It is generated and populated at runtime.</li>
<li><code>.data</code> : this section is used to store initialized global variable. If in your code you have the statement <code>int a = 5;</code> outside of any function or module, this information will be stored in this section.</li>
<li><code>.rdata</code> : this section is used to store initialized read-only global variable. These variables will not change during the whole program execution. For example, the statement <code>const int a = 5;</code> outside of any function or module will likely end in the <code>.rdata</code> section.</li>
<li><code>.pdata</code> : this section is used to store the functions used for error handling. This section contains all the information needed to unwind the stack when an exception is raised. Its content is really interesting to implement <code>Thread Stack Spoofing</code>.</li>
<li><code>.xdata</code> : this section is used to store the <code>.pdata</code> exception information.</li>
<li><code>.idata</code> : this section is used to store the import directory table that is used to store the addresses used during <code>DLL</code> loading.</li>
<li><code>.reloc</code> : this section is used to store relocation information. When a program is compiled, the compiler choose a base import address. This address is the one where the program will be loaded in memory. But if this address is already used, the <code>OS</code> will load it at another random address not known during compile time. This load address shift will break references to symbols that use absolute address. Indeed, if a symbols is supposed to be located at <code>baseAddress + 0x10</code>, the base address shift will break the reference. The <code>.reloc</code> section contains all the information needed to easily relocate these symbols depending on the executable load address.</li>
</ul>
<h2 id="reference-to-functions-and-variables-during-execution">Reference to functions and variables during execution</h2>
<p>The <code>PE</code> contains all the data needed to run the program. The <code>.text</code> section contains the executable code but usually all variables or functions are contained in other sections. Thus, during execution time, the code must be able to find these references <em>ie, it must be able to find the address of the symbol in its definition section</em>.</p>
<p>For example, the following <code>C</code> code:</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-keyword">char</span> myVariable[<span class="hljs-number">16</span>] = <span class="hljs-string">&quot;Hello World !\n&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, myVariable);
}
</code></pre>
<p>Once decompiled during execution, the main function looks like this :</p>
<pre><code>00007FF7390B187B  lea         rdx,[myVariable (7ff6c959c000h)]  
00007FF7390B1882  lea         rcx,[string &quot;%s&quot; (7ff6c9599c24h)]  
00007FF7390B1889  call        printf (7ff6c959118bh)
</code></pre><p>Following the standard <code>x64</code> argument convention, the two <code>printf</code> arguments are stored in <code>RDX</code> and <code>RCX</code>.</p>
<p>Looking at the memory mapping using <code>vmmap</code> or <code>ProcessHacker</code>, the following section mapping is performed:</p>
<p><img src="img/CoffLoader/PE/SectionMapping.jpg" alt="Section mapping performed"></p>
<p>The section with <code>RX</code> rights is the <code>.text</code> section.</p>
<p>When the <code>PE</code> is loaded in memory, the sections are mapped in the same order they are defined in the <code>PE</code> :</p>
<ul>
<li><code>.text</code> :  0x7ff6c9591000</li>
<li><code>.rdata</code>:  0x7ff6c9599000</li>
<li><code>.data</code> :  0x7ff6c959c000</li>
</ul>
<p>Opening the section <code>.data</code> displays the <code>myVariable</code> value that is <code>Hello World!</code>.</p>
<p>Thus, when a global data is used in <code>C</code>, the compiler will store the data in the <code>.data</code> section and replace each use of the data by its address in the <code>ASM</code> generated code.</p>
<p>The same analysis can be done with the following code :</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> myReadOnlyVariable[<span class="hljs-number">16</span>] = <span class="hljs-string">&quot;ReadOnly \n&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, myReadOnlyVariable);
}
</code></pre>
<p>This time, due to the use of <code>const</code> the variable will be located in the <code>.rdata</code> section.</p>
<p>So, when a <code>C</code> code is compiled and linked, the <code>ASM</code> generated code is located in the <code>.text</code> section, the variables, functions and libraries are located in the other sections depending on their uses. Finally, the <code>.text</code> section is modified to point on the right section each time a variable or a function is referenced.</p>
<p>Usually, the <code>.text</code> section does not contain any data but just references (<em>addresses</em>) to the section containing the data. This behavior can be tweaked through compiler and linker option but we will just sticking up to the general case.</p>
<h1 id="object-files">Object files</h1>
<h2 id="overview">Overview</h2>
<p>Object files are binary files generated during a program compilation. The generated object files are then linked to generate the <code>PE</code> executable:</p>
<p><img src="img/CoffLoader/COFF/Compiler.jpg" alt="Compilation step"></p>
<p>The compiler transforms the source code into object files. These files contain exactly the same amount of information the source code has but cannot be understood by the <code>OS</code>. Moreover, the compilation generate <code>symbols</code> that represent the variable but these <code>symbols</code> do not point to anything.</p>
<p>For example, if one variable is defined in the <code>file1.c</code> but used in the <code>file2.c</code>, and the <code>file2.o</code> file is &quot;executed&quot; by the <code>OS</code> it will not be able to find the variable defined in <code>file1.c</code> and the &quot;program&quot; will crash.</p>
<p>For example, the following code:</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// file1.c</span>
<span class="hljs-keyword">char</span> myVariable[<span class="hljs-number">16</span>] = <span class="hljs-string">&quot;Hello World !\n&quot;</span>;

<span class="hljs-comment">// file2.c </span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> myVariable[<span class="hljs-number">16</span>];
<span class="hljs-function"><span class="hljs-keyword">int</span> main <span class="hljs-title">void</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, myVariable);
}
</code></pre>
<p>Once disassembled, the main function contained in <code>file2.obj</code> looks like:</p>
<pre><code>  000000000000001B: 48 8D 15 00 00 00 00  lea         rdx,[myVariable]
  0000000000000022: 48 8D 0D 00 00 00 00  lea         rcx,[??_C@_02DKCKIIND@?$CFs@]
  0000000000000029: E8 00 00 00 00        call        __imp_printf
</code></pre><p>Instead of getting addresses, as for full compiled <code>PE</code>, the <code>Object File</code> uses <code>symbols</code>.</p>
<ul>
<li><code>myVariable</code> is the symbol that represents the variable <code>myVariable</code> defined in <code>file1.c</code></li>
<li><code>??_C@_02DKCKIIND@?$CFs@</code> is the symbol that represents the <code>%s</code></li>
<li><code>__imp_printf</code> is the symbol that represents the <code>printf</code> function.</li>
</ul>
<p>As it can be seen the object file contains all the symbols, but if the raw bytes are analyzed, the address that should point to the symbol is empty (<code>0x000000</code>). Thus, the object file cannot be executed as a <code>PE</code>.</p>
<p>Making the cross reference between object file and generating the address of each symbol is the <code>linker</code> job.</p>
<p>During the compilation time, the variables and functions defined in the source code are transformed into symbols in the object files. The linker will then process the symbol of each object files, cross reference them, generate the address and build the executable.</p>
<p><img src="img/CoffLoader/COFF/Compile2.jpg" alt="Compilation and linking"></p>
<p>On the previous example, the linker will map all the <code>file1.o</code> symbols and give them an address in the file. Then, it will map all the symbols of <code>file2.o</code> and resolve the external symbol <code>myVariable</code> to its definition address defined during the <code>file1.o</code> mapping.</p>
<h2 id="coff-loader">Coff Loader</h2>
<p>A <code>COFF Loader</code> is a program that will take an object file as input, will resolve all symbols to make it executable by the <code>OS</code>, store the symbols in memory and run the program described by the object file in-memory. </p>
<p>Thus a <code>COFF Loader</code> is more or less a mini-linker that will perform in-memory linking and execution.</p>
<p>For now, each time the word <code>COFF</code> is used, it will designate a <code>Windows</code> object file. Likewise, the <code>BOF</code> name can also be used.</p>
<h3 id="bof-or-coff-">BOF or COFF ?</h3>
<p>A <code>COFF Loader</code> is implemented is <code>Cobalt Strike</code>. The <code>COFF</code> used are modified program integrating functions that can interact with the <code>CobaltStrike</code> beacon enhance the name <code>Beacon Object File</code> or simply <code>BOF</code>. For instance, if you run the <code>COFF</code> <code>wohami.o</code>, the answer will be prompted to the standard <code>stdin</code> thus, will not be retrieved by the beacon and the operator will not be able to see the output.</p>
<p>The fix this problem, the <code>whoami.o</code> <code>COFF</code> support some functions that can be used to talk with the beacon and send back execution output to the operator.</p>
<h3 id="bof-advantages">BOF advantages</h3>
<p>Several technics can be used to execute binary in-memory. For example <code>C# inline assembly</code>,  <code>C++ ReflectiveDLL</code> or <code>Powershell IEX</code>. However, these technics are based on a <code>forkNrun</code> pattern that involves process creation and process injection. They can be detected by security solutions as they let an important in-memory footprint and use heavily monitored <code>WindowsAPI</code> such as <code>OpenProcess</code>, <code>WriteProcessMemory</code> or <code>CreateRemoteThreadEx</code>. </p>
<p>On the other hand, <code>BOF</code> can be executed in the current process and all the memory allocated can be cleaned after execution. Thus, its memory footprint is very small and its detection harder.</p>
<p>Finally, the <code>BOF</code> generated executables are smaller and thus easier to be sent to the beacon over the network. For example, the <code>whoami.exe</code> executable size is 72kB, the <code>BOF</code> version is less than 7kB.</p>
<h3 id="bof-disadvantage">BOF disadvantage</h3>
<p>Every techniques have their advantages and drawback. 
The main disadvantage of <code>BOF</code> is they share the same process as the beacon. Thus, the beacon cannot make any other actions while the <code>BOF</code> is executed.</p>
<p>Likewise, if the <code>BOF</code> crashes during its execution, it will also kill the beacon.</p>
<p>Finally, even if <code>BOF</code> development is not really difficult, they must be singled threaded and the whole code must be written in a single file. Thus, it can be hard to create an advanced application using only <code>BOF</code>. </p>
<p>For example, creating a <code>BOF</code> version of <code>Rubeus</code> or <code>Mimikatz</code> can be quite challenging (but if you have one, please share it with me...)</p>
<h1 id="hands-on--coff-loader">Hands on : COFF Loader</h1>
<h2 id="blueprint">Blueprint</h2>
<p>In order to develop the <code>COFF Loader</code> , the following tasks must be tackled down:</p>
<ul>
<li>Parse the <code>COFF</code> file according to the <code>COFF</code> specification</li>
<li>Retrieve the <code>COFF</code> sections and map them in memory</li>
<li>Resolve symbols and modify the sections to set the right reference address in the sections</li>
<li>Resolve the external functions (such as <code>printf</code>) to set the right address in the sections</li>
<li>Retrieve the section containing the executable code</li>
<li>Run the code</li>
</ul>
<h2 id="coff-specification">COFF specification</h2>
<p>A first approach of <code>COFF</code> specification has been seen in the <code>PE</code> part. However, <code>COFF</code> specification for <code>PE</code> and for <code>Object File</code> are similar but not identical.</p>
<p>Indeed, the principle is the same, the <code>COFF</code> file is a book and is segmented in different sections. Among these sections there are the <code>.text</code>, <code>.data</code>, <code>.rdata</code> etc... with the same definition as those for the <code>PE</code>. However, the data contained in each section header is quite different. Moreover, other new parts are added. </p>
<p>The <code>COFF</code> specification for <code>Object File</code> contains a <code>Symbol Table</code> that summarizes all symbols used and a <code>Symbol String Table</code> that contains the name of each symbol.</p>
<p>Likewise, there is not any <code>.reloc</code> section in <code>COFF</code> file but there is a <code>Relocation Table</code> that contains all the information needed to resolve symbols, compute their address and modify the sections&apos; code to fix symbols references.</p>
<p>The following figure summarizes the structure of a <code>COFF</code> file:</p>
<p><img src="img/CoffLoader/HandsOn/COFFStruct.jpg" alt="COFF File structure"></p>
<h3 id="coff-header">COFF Header</h3>
<p>The <code>COFF</code> header specification can be found <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-file-header-object-and-image" target="_blank">here</a> in the <code>Microsoft</code> documentation.</p>
<p>The file header starts at the offset 0. The following <code>C</code> structure can be used to handle the <code>COFF</code> header:</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _CoffHeader {
    <span class="hljs-keyword">uint16_t</span>    machine;
    <span class="hljs-keyword">uint16_t</span>    numberOfSections;
    <span class="hljs-keyword">uint32_t</span>    timeDateStamp;
    <span class="hljs-keyword">uint32_t</span>    pointerToSymbolTable;
    <span class="hljs-keyword">uint32_t</span>    numberOfSymbols;
    <span class="hljs-keyword">uint16_t</span>    sizeOfOptionalHeader;
    <span class="hljs-keyword">uint16_t</span>    characteristics;
} CoffHeader;
</code></pre>
<p>The <code>machine</code> value is a number defining for which architecture the <code>COFF</code> file have been compiled. For example, the value <code>0x8664</code> represents an <code>x64</code> architecture.</p>
<p>The value <code>pointerToSymbolTable</code> is the offset of the symbol table. Thus, the header can be used to directly jump to the <code>Symbol Table</code> :</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// void *data : address of the first COFF byte</span>

CoffSymbol* firstSymbol = data + coffHeader.pointerToSymbolTable;
</code></pre>
<p>The optional headers are empty on a <code>File Object COFF</code> structure.</p>
<p>The <code>characteristic</code> value represents the <code>COFF</code> type and its possible values are resumed in the <code>Microsoft</code> <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics" target="_blank">documentation</a>.</p>
<h3 id="sections-header">Sections Header</h3>
<p>Right after the file header, there are the section headers. These headers contains all the information needed to access the data contained in the different sections.
The specification about section headers can be found <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-table-section-headers" target="_blank">here</a> in the <code>Microsoft</code> documentation.</p>
<p>The following <code>C</code> structure can be used to handle the sections header :</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _CoffSection {
    <span class="hljs-keyword">char</span>        name[<span class="hljs-number">8</span>];
    <span class="hljs-keyword">uint32_t</span>    virtualSize;
    <span class="hljs-keyword">uint32_t</span>    virtualAddress;
    <span class="hljs-keyword">uint32_t</span>    sizeOfRawData;
    <span class="hljs-keyword">uint32_t</span>    pointerToRawData;
    <span class="hljs-keyword">uint32_t</span>    pointerToRelocations;
    <span class="hljs-keyword">uint32_t</span>    pointerToLinenumber;
    <span class="hljs-keyword">uint16_t</span>    numberOfRelocations;
    <span class="hljs-keyword">uint16_t</span>    numberOfLinenumber;
    <span class="hljs-keyword">uint32_t</span>    characteristics;
} CoffSection;
</code></pre>
<p>The <code>name</code> value is the section name (<code>.text</code>, <code>.data</code>, etc...). Not so much to say about it.</p>
<p>The <code>virtualSize</code> and <code>virtualAddress</code> values are always set to <code>0</code> in <code>COFF</code> file as they are meant to contains the data once the <code>PE</code> is loaded in memory.</p>
<p>The <code>pointerToRawData</code> data is the offset used to access to the data contained in the section. For example, if the section is the <code>.text</code> section, <code>pointerToRawData</code> data will point to the first executable bit. The value is absolute (<em>ie from the byte 0 of the file</em>) and not relative from the section (<em>ie from the section address</em>).</p>
<p>The <code>pointerToRelocations</code> data is the offset used to access to the <code>Relocation Table</code> linked to the section (<em>see the next part about relocation</em>). As for the <code>pointerToRawData</code>, the offset is absolute and not relative.</p>
<p>The <code>pointerToLinenumber</code> is usually 0 or can be ignored as this field is deprecated in <code>COFF</code> compilation.</p>
<h3 id="navigate-into-sections">Navigate into sections</h3>
<p>During the <code>COFF</code> file parsing, it will be needed to navigate through the different sections. This can easily be done by leveraging the following facts :</p>
<ul>
<li>The total number of sections is given in the file header</li>
<li>The first section header is located right after the file header</li>
<li>The size of the file and section headers are constant and known</li>
<li>The different section headers are stored in a continuous way</li>
</ul>
<p>Thus, to access to the section <code>i</code> the following pseudo-code can be used:</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// void *data : address of the first COFF byte</span>
CoffSection* section_i = data + HEADER_SIZE + i * SECTION_SIZE
</code></pre>
<h3 id="relocations-table">Relocations Table</h3>
<p>This table contains all the information needed to resolve symbols and modify the segment code to inject the symbol address.</p>
<p>Once again, as an example, the following code is used:</p>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World !\n&quot;</span>);
}
</code></pre>
<p>The decompiled code stored in the <code>Object File</code> <code>.text</code> section is the following:</p>
<pre><code>.text
  000000000000001B: 48 8D 0D 00 00 00 00 lea         rcx,[??_C@_0M@KPLPPDAC@Hello?5World@]
  0000000000000022: E8 00 00 00 00       call        __imp_printf
</code></pre><p>The addresses contained in the section are <code>0x00000000</code>. If the <code>.text</code> section is loaded in memory as-is and run, the program will try to access to the address <code>0x00000000</code> and will crash.</p>
<p>Thus, a relocation must be performed to replace the fake symbol address by the real one.</p>
<p>On this example, two relocations must be performed : the <code>??_C@_0M@KPLPPDAC@Hello?5World@</code> and the <code>__imp_printf</code>.</p>
<p>Thus, two entries will be present in the <code>.text</code> section relocation table.</p>
<p>The following <code>C</code> structure can be used to handle each relocation entry:</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _CoffReloc {
    <span class="hljs-keyword">uint32_t</span>    virtualAddress;
    <span class="hljs-keyword">uint32_t</span>    symbolTableIndex;
    <span class="hljs-keyword">uint16_t</span>    type;
} CoffReloc;
</code></pre>
<p>The <code>virtualAddress</code> value is the relative offset from the section start to the first byte of the address to modify.</p>
<p>If the <code>.text</code> section contains only these two lines :</p>
<pre><code>  000000000000001B: 48 8D 0D 00 00 00 00 lea         rcx,[??_C@_0M@KPLPPDAC@Hello?5World@]
  0000000000000022: E8 00 00 00 00       call        __imp_printf
</code></pre><p>The virtual address for the relocations will be <code>0x03</code> and <code>0x08</code>.</p>
<p>The <code>symbolTableIndex</code> value contains the index of the symbol in the <code>Symbol Table</code>. This value is used to retrieve information about the symbol that must be relocated in the section.</p>
<p>The <code>type</code> value is the relocation type <em>ie the way the symbol address must be given in the section</em>. These codes are dependent of the architecture. Only the interesting codes for <code>x64</code> will be explained.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_REL_AMD64_ABSOLUTE</td>
<td>0x0000</td>
<td>The relocation is ignored</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_ADDR64</td>
<td>0x0001</td>
<td>The symbol reference address in the section must be replaced by the 64bits absolute address of the symbol.</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_ADDR64</td>
<td>0x0002</td>
<td>The symbol reference address in the section must be replaced by the 32bits absolute address of the symbol.</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_ADDR32NB</td>
<td>0x0003</td>
<td>The symbol reference address in the section must be replaced by the 32bits relative address of the symbol from the current section</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_REL32</td>
<td>0x0004</td>
<td>The symbol reference address in the section must be replaced by the 32bits relative address of the symbol from the current section minus an offset of 0 bits</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_REL32_1</td>
<td>0x0005</td>
<td>The symbol reference address in the section must be replaced by the 32bits relative address of the symbol from the current section minus an offset of 1 bits</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_REL32_2</td>
<td>0x0006</td>
<td>The symbol reference address in the section must be replaced by the 32bits relative address of the symbol from the current section minus an offset of 2 bits</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_REL32_3</td>
<td>0x0007</td>
<td>The symbol reference address in the section must be replaced by the 32bits relative address of the symbol from the current section minus an offset of 3 bits</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_REL32_4</td>
<td>0x0008</td>
<td>The symbol reference address in the section must be replaced by the 32bits relative address of the symbol from the current section minus an offset of 4 bits</td>
</tr>
<tr>
<td>IMAGE_REL_AMD64_REL32_5</td>
<td>0x0009</td>
<td>The symbol reference address in the section must be replaced by the 32bits relative address of the symbol from the current section minus an offset of 5 bits</td>
</tr>
</tbody>
</table>
<p>Other relocation types exist and are referenced in the <code>Microsoft</code> <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-table-section-headers" target="_blank">documentation</a> but they are hardly ever used or only for debugging purpose.</p>
<p>Thus only these relocation types will be handled here.</p>
<h3 id="absolute-and-relative-address">Absolute and Relative address</h3>
<p>In the relocation description, the term absolute and relative address is used. Depending on the relocation type, one or the other must be computed.</p>
<p>This part aims to explain the difference between absolute and relative address.</p>
<p>The following example could help to see the difference between these two address types.</p>
<p><hr>
Michel TheHacker lives in a very small city with only one street. The street is one way and Michel lives in the 50th house. </p>
<p>When he gives his address to a stranger, he always count the number of houses between his and the beginning of the street. His address is then 50. This is called absolute address. </p>
<p>However, when he gives his address to one of his friends living in the same street, he always gives the number of houses between his house and his friend house. Thus, for Robert, a Michel friend, living in the house 12, Michel&#x2019;s address is 38 as there are 38 houses between his and Michel one&apos;s. This is called relative address.</p>
<hr>

<p>In a nutshell, an absolute address allows anyone to reach the destination while a relative address allows only one person to reach the destination.</p>
<p>With <code>COFF</code> file, the same principle can be applied. THE symbol absolute address is its address from the file start. A symbol relative address is its address from a given position in the file (the relocation address for example).</p>
<p>The following figure can help to visualize how to compute the relative addresses :</p>
<p><img src="img/CoffLoader/HandsOn/AbsoluteAddresses.jpg" alt="Compute absolute and relative addresses"></p>
<p>Knowing that, when a relative address is needed, the following formula can be used to compute the symbol relative address of a symbol from a section start:</p>
<pre><code class="lang-c"><span class="hljs-comment">// Compute the relative address of a symbol from a given section</span>
RelativeAddress(Symbol) = AbsoluteAddress(Symbol) - AbsoluteAddress(Section)
</code></pre>
<p>The absolute address can be easily computed with the following formula:</p>
<pre><code class="lang-c">AbsoluteAddress(Symbol) = AbsoluteAddress(SymbolTable) + Offset(Symbol in SymbolTable)
</code></pre>
<p>These addresses can then be written in the corresponding section.</p>
<h3 id="symbol-table">Symbol Table</h3>
<p>This table contains all the data related to the symbols. It includes their name, type and storage addresses.
The following <code>C</code> structure can be used to handle each symbol entry:</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _CoffSymbol {
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">char</span>        name[<span class="hljs-number">8</span>];
        <span class="hljs-keyword">uint32_t</span>    value[<span class="hljs-number">2</span>];
    } first;
    <span class="hljs-keyword">uint32_t</span>    value;
    <span class="hljs-keyword">uint16_t</span>    sectionNumber;
    <span class="hljs-keyword">uint16_t</span>    type;
    <span class="hljs-keyword">uint8_t</span>        storageClass;
    <span class="hljs-keyword">uint8_t</span>        numberOfAuxSymbols;

} CoffSymbol;
</code></pre>
<p>The <code>first</code> value is a union. It can handle two types of data depending on the symbol:</p>
<ul>
<li>The symbol name is fewer than 8 characters : the <code>first.name</code> value will contain the name of the symbol</li>
<li>The symbol name is greater than 8 characters : the <code>first.name[0]</code> will be equal to <code>0</code> and the <code>first.value</code> will contains the offset of the symbol name in the <code>Symbol Sting Table</code>.</li>
</ul>
<p>When the name is greater than 8 characters, the full-symbol name can be retrieved with the following code:</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-keyword">char</span> *name = symbolStringTable + coffSymbol.first.value
</code></pre>
<p>The <code>value</code> value is the symbol value. This entry can have different meanings depending on the symbol storage class.</p>
<p>The <code>sectionNumber</code> value is the section index where the symbol data is stored.</p>
<p>The <code>type</code> value is the type of the symbol <em>ie the type of the value it represents</em>. For example, it could be <code>DT_CHAR</code>, <code>DT_INT</code>, <code>DT_FUNCTION</code>. Usually, this field is not really used and is either <code>DT_FUNCTION</code> or <code>0</code>.</p>
<p>The <code>storageClass</code> value represents how the data is actually stored in this symbol. The following table contains the main possible values and their specificities:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_SYM_CLASS_NULL</td>
<td>0x0</td>
<td>No storage type</td>
</tr>
<tr>
<td>IMAGE_SYM_CLASS_NULL_AUTO</td>
<td>0x01</td>
<td><code>auto</code> type. It is usually used for auto-allocated values stored in the stack</td>
</tr>
<tr>
<td>IMAGE_SYM_CLASS_EXTERNAL</td>
<td>0x02</td>
<td>The symbol is defined in another <code>COFF</code> object. If the section number is 0, the symbol&apos;s value represent the symbol size, otherwise it represents the symbol offset within its section</td>
</tr>
<tr>
<td>IMAGE_SYM_CLASS_STATIC</td>
<td>0x03</td>
<td>The symbol defined a static value. If the symbol&apos;s value is not 0, it represents the symbol offset within its section</td>
</tr>
</tbody>
</table>
<p>Thus, if the symbol storage class is either <code>IMAGE_SYM_CLASS_STATIC</code> or <code>IMAGE_SYM_CLASS_EXTERNAL</code> with a non <code>0</code> section index, the symbol address can be computed as follows:</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-keyword">void</span> *symbolAddress = sections[coffSymbol.sectionIndex].pointerToRawData + coffSymbol.value;
</code></pre>
<p>Finally, the <code>numberOfAuxSymbols</code> represents the number of auxiliary symbols that are contained right after the symbol record. </p>
<p><img src="img/CoffLoader/HandsOn/AuxilarySymbols.jpg" alt="Auxiliary Symbols"></p>
<p>These auxiliary symbols are usually linker specific and thus can be ignored for now as the <code>COFFLoader</code> does not link different object files to one another. They give additional information about the linked symbol. For example, in case of a symbol defining a function, the additional symbol can contain information about the total size of the function. </p>
<p>This additional information is not really needed for the <code>COFFLoader</code>.</p>
<h3 id="symbol-table-string">Symbol Table String</h3>
<p>This table just contains the name of the symbols</p>
<p><img src="img/CoffLoader/HandsOn/SymbolTableString.jpg" alt="Symbol Table String"></p>
<p>This table is used to resolve symbols&apos; name whose size is greater than 8 characters (see previous section about Symbol Table)</p>
<h3 id="conclusion">Conclusion</h3>
<p>So now, all information is given to allow anyone to easily parse a <code>Windows</code> <code>COFF</code> file. It is possible to retrieve the <code>COFF</code> header, iterate through the different sections, retrieve their raw data. It is then possible to parse the relocation tables associated to each section and retrieve all the symbols needed.</p>
<p>Time to start mapping all these things in memory.</p>
<h2 id="write-sections-in-memory">Write sections in memory</h2>
<p>The sections contain all the interesting data used by the program. Indeed, the compiled code is contained in the <code>.text</code> section and the variable in the <code>.XXXdata</code> sections.</p>
<p>The first thing to do is to parse all these sections and map them in memory. This can be done with the following code:</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// void *data : represent the first byte of the COFFFile</span>
<span class="hljs-comment">// void **sectionAddressMemory : table that will store section&apos;s allocated memory address</span>

<span class="hljs-comment">// Retrieve the header and fill the CoffHeader structure. In C a simple cast does the job.</span>
CoffHeader *coffHeader = (COFFHeader *)<span class="hljs-function">data
<span class="hljs-title">for</span><span class="hljs-params">(size_t i = <span class="hljs-number">0</span>; i &lt; coffHeader-&gt;numberOfSections; i++)</span></span>{

    <span class="hljs-comment">// Get the current section</span>
    CoffSection *section = (CoffSection *)(data + HEADER_SIZE + SECTION_SIZE * i);

    <span class="hljs-comment">// Allocate the memory</span>
    sectionAddressMemory[i] = VirtualAlloc(section-&gt;sizeOfRawData);

    <span class="hljs-comment">// Write section data in the allocated memory</span>
    CopyMemory(sectionAddressMemory[i], data + section-&gt;pointerToRawData, section-&gt;sizeOfRawData);
}
</code></pre>
<p>So now, all sections are mapped in memory. The relocations can be performed directly in memory.</p>
<h2 id="perform-relocations">Perform relocations</h2>
<p>Once the sections are mapped in memory, each relocation entry must be parsed and performed in order to map the symbol address in the section code.</p>
<p>The idea is to replace the current section code :</p>
<pre><code>  000000000000001B: 48 8D 0D 00 00 00 00 lea         rcx,[??_C@_0M@KPLPPDAC@Hello?5World@]
  0000000000000022: E8 00 00 00 00       call        __imp_printf
</code></pre><p>By </p>
<pre><code>  000000000000001B: 48 8D 0D XX XX XX XX lea         rcx,[??_C@_0M@KPLPPDAC@Hello?5World@]
  0000000000000022: E8 YY YY YY YY       call        __imp_printf
</code></pre><p>Where <code>XX XX XX XX</code> points to the <code>??_C@_0M@KPLPPDAC@Hello?5World@</code> definition address and <code>YY YY YY YY</code> point to the <code>printf</code> definition address.</p>
<p>The relocation of external functions such as <code>printf</code> are quite special. Thus, symbols will be separated in two categories :</p>
<ul>
<li>Standard symbols : symbol whose relocation can be directly performed such as standard initialized variable or internal functions</li>
<li>Special symbols : symbol that must be pre-processed before being rellocated such as uninitialized variable or external functions.</li>
</ul>
<h3 id="special-symbol">Special symbol</h3>
<p>The special symbols are symbols that could not be easily resolved through lookup in the different <code>COFF</code> file sections.</p>
<p>For example, an internal function <code>funct1</code>, that is defined directly in the <code>C</code> file used to generate the <code>COFF</code> file will have all its body contained in a section (usually the <code>.text</code> section). Its symbol can thus be resolved through a simple lookup at the right <code>COFF</code> section.</p>
<p>However, what happens for functions defined in an external library such as the <code>printf</code> function ?</p>
<h4 id="external-functions">External functions</h4>
<p>External functions are all functions that are not directly defined in the <code>C</code> source file used to generate the <code>COFF</code> file. These function symbols definition do not point to a valid section in the <code>COFF</code> file:</p>
<p><img src="img/CoffLoader/HandsOn/ExternalFunctions.jpg" alt="External function symbol in COFF file"></p>
<p>This figure shows that the <code>sectionNumber</code> for this symbol is 0. Thus, it cannot be resolved as it will not be possible to find its address in one of the <code>COFF</code> section.</p>
<p>This is where the <code>Global Offset Table</code> saves the day. This table can be seen as a made-up section that is generated at run time. This section is used to reference address to functions defined in shared libraries or <code>DLL</code> and serves as a lookup table.</p>
<p>For example, the <code>printf</code> function is defined in the <code>MSVCRT</code> <code>Windows</code> library. During the runtime, the <code>OS</code> will search the <code>printf</code> function address in the <code>MSVCRT</code> library (* with <code>GetProcAddress</code> for example) and fill the <code>GOT</code> with this address. When the program tries to access the <code>printf</code> function, it will point on the <code>GOT</code> and gets the address previously fetched by the system.</p>
<p>The idea is to simulate this process. First a new section will be allocated in memory:</p>
<pre><code class="lang-c"><span class="hljs-comment">//pseudo code</span>
<span class="hljs-keyword">void</span> *got = VirtualAlloc(<span class="hljs-number">1024</span>);
</code></pre>
<p>The <code>printf</code> function is resolved using <code>GetModuleHandle</code> and <code>GetProcAddress</code> to retrieve the function address in the library. Then the address is copied in the <code>GOT</code> section previously allocated and resolve the <code>__imp_printf</code> to the <code>GOT</code> address.</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-keyword">void</span> *printfAddress = GetProcAddress(GetModuleHandle(<span class="hljs-string">&quot;MSVCRT&quot;</span>), <span class="hljs-string">&quot;printf&quot;</span>);
<span class="hljs-keyword">void</span> *nextFreeGotSlot = got + gotSize * <span class="hljs-number">0x08</span>;
CopyMemory(nextFreeGotSlot, &amp;printfAddress, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>));
gotSize += <span class="hljs-number">1</span>;
<span class="hljs-keyword">void</span> *absoluteSymbolAddress = nextFreeGotSlot;
</code></pre>
<p>From now, the <code>absoluteSymbolAddress</code> will be used as the absolute address to the <code>__imp_printf</code> symbol definition.</p>
<p>This is equivalent to modify the <code>CoffSymbol</code> structure by changing the <code>sectionNumber</code> from <code>0</code> to <code>.got</code> and filling the <code>.got</code> section with resolved function addresses.</p>
<h4 id="uninitialized-variables">Uninitialized variables</h4>
<p>When a global un-initialized variable is defined in the source code, its symbol is created in the <code>COFF</code> file. However, as it is uninitialized, its value is not mapped in any sections.</p>
<p>Usually, this variable will end in the <code>.bss</code> section that is created at run time.</p>
<p>The idea is to create a new section that will emulate the <code>.bss</code> section.</p>
<pre><code class="lang-c"><span class="hljs-comment">//pseudo code</span>
<span class="hljs-keyword">void</span> *bss = VirtualAlloc(<span class="hljs-number">1024</span>);
</code></pre>
<p>The un-initialized symbols will then be resolved on an addresse contained in the newly created <code>.bss</code> section as the external functions are in the <code>.got</code> section.</p>
<p>However, for the functions in the <code>.got</code> , the symbol size is always the same : the size of the function address. For symbols resolved in the <code>.bss</code> , the size is the variable size.</p>
<p>For example, a <code>uint32_t</code> symbol will ne take the same space in the <code>.bss</code> as a <code>uint64_t</code> symbol. Likewise, a <code>char[10]</code> will take twice the space used by a <code>char[5]</code>. Hopefully, the size of the symbol is given in the symbolic value attribute in its <code>CoffSymbol</code> structure.</p>
<p><img src="img/CoffLoader/HandsOn/bssVariableSymbol.jpg" alt="Global un-initialized symbol"></p>
<p>In this example, the <code>plop</code> symbol represents an initialized variable whose size is <code>0x0B</code> bytes. This information can be used to allocate enough space for each symbol.</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// void *bss : the allocated address for the .bss section</span>
<span class="hljs-comment">// size_t bssOffset : the size already used in the .bss section</span>

<span class="hljs-keyword">size_t</span> symbolSize = coffSymbol-&gt;value;
<span class="hljs-keyword">void</span> *absoluteSymbolAddress = bss + bssOffset;

<span class="hljs-comment">// The next symbol will be resolved after the current one in the .bss</span>
bssOffset += symbolSize;
</code></pre>
<p>Then, each time the un-initialized variable symbol is referenced, it will be resolved to the <code>absoluteSymbolAddress</code> address.</p>
<p>This is equivalent to modify the <code>CoffSymbol</code> structure by changing the <code>sectionNumber</code> from <code>0</code> to <code>.bss</code> and modifying the <code>value</code> field with the <code>.bss</code> offset used.</p>
<h4 id="detect-and-process-special-symbols">Detect and process special symbols</h4>
<p>The whole game is to be able to make the difference between a standard symbol that can be directly relocated and a non-standard symbol that must be pre-processed before being relocated.</p>
<p>The non-standard symbols are, actually, the symbols that cannot be resolved directly in the <code>COFF</code> file. This feed through having an undefined section index (<em><code>sectionNumber</code> value set to 0 in the <code>CoffSymbol</code> structure</em>) and having the <code>IMAGE_SYM_CLASS_EXTERNAL</code> storage class.</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-keyword">if</span>(coffSymbol-&gt;storageClass == IMAGE_SYM_CLASS_EXTERNAL &amp;&amp; coffSymbol-&gt;sectionIndex == <span class="hljs-number">0</span>){
    <span class="hljs-comment">// process non standard symbol</span>
}
</code></pre>
<p>Once the non-standard symbol is detected, the difference between an external function and an un-intialized variable must be done. </p>
<p>The external function symbols&apos; name is quite recognizable as it always starts with <code>__imp_</code>. If the symbol name starts with this pattern, it could be assumed it represents a function.</p>
<pre><code class="lang-c"><span class="hljs-comment">//pseudo code</span>
<span class="hljs-keyword">char</span>* symbolName = resolveSymbolName(coffSymbol);
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(symbolName, <span class="hljs-string">&quot;__imp_&quot;</span>, <span class="hljs-number">6</span>) == <span class="hljs-number">0</span>){
    <span class="hljs-comment">// process the function</span>
}
<span class="hljs-keyword">else</span>{
    <span class="hljs-comment">// process the uninitialized variable</span>
}
</code></pre>
<p>The un-initialized variable symbol processing is quite straight forward, but for functions it requires more work. Indeed, in order to resolve the function in its shared library, the library name and the function name must be known.</p>
<p>However, in a common <code>COFF</code> file the function symbol only contains the function name (<em>ie __imp_printf</em>). This can be solved through the <code>Dynamic Function Resolution</code> convention. The <code>DFR</code> set a specific syntax for external function definition and name.</p>
<p>The following code shows the <code>Hello world</code> program using <code>DFR</code>:</p>
<pre><code class="lang-c">DECLSPEC_IMPORT <span class="hljs-keyword">int</span> __cdecl MSVCRT$<span class="hljs-built_in">printf</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* test, ...);

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    MSVCRT$<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World !\n&quot;</span>);
}
</code></pre>
<p>In this convention, the library name is added to the function name. After compilation, the <code>printf</code> symbol will look like <code>__imp_MSVCRT$printf</code>.</p>
<p>This syntax solve all the problems as the shared library named is included in the symbol name. The function can then be resolved like this:</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// char* symbolName : the symbol name</span>

<span class="hljs-comment">// Remove the __imp_</span>
symbolName += <span class="hljs-number">6</span>;
<span class="hljs-keyword">char</span> *splittedName = symbolName.split(<span class="hljs-string">&apos;$&apos;</span>);
<span class="hljs-keyword">char</span> *libraryName = splittedName[<span class="hljs-number">0</span>];
<span class="hljs-keyword">char</span> *functionName = splittedName[<span class="hljs-number">1</span>];
<span class="hljs-keyword">void</span> *functionAddress = GetProcAddress(GetModuleHandle(libraryName), functionName);
</code></pre>
<p>Thus, when writing <code>BOF</code> the <code>DFR</code> convention must be followed. To avoid heavy syntax, a simple typedef can be performed:</p>
<pre><code class="lang-c">DECLSPEC_IMPORT <span class="hljs-keyword">int</span> __cdecl MSVCRT$<span class="hljs-built_in">printf</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* test, ...);
<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">printf</span> MSVCRT$<span class="hljs-function"><span class="hljs-built_in">printf</span>

<span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World !\n&quot;</span>);
}
</code></pre>
<h4 id="conclusion">Conclusion</h4>
<p>From now, all symbols represented in the <code>COFF</code> file can be resolved to an address in memory. The functions will be resolved to the newly created <code>.got</code> section and the un-initialized variable will be resolved to the new created <code>.bss</code> section. They can then be processed as standard symbols as long as their definition address used during the relocation is the one pointing to the <code>.got</code> or the <code>.bss</code>.</p>
<p>Finally, the functions address can be resolved through the <code>GetModuleHandle</code> and <code>GetProcAddress</code> thanks to the <code>Dynamic Function Resolution</code> convention.</p>
<p>Let&apos;s remap the symbol in the section !</p>
<h3 id="standard-symbol-relocation">Standard symbol relocation</h3>
<p>These symbols can be relocated quite easily. In order to perform the relocation three information are needed:</p>
<ol>
<li>The relocation type : to know in wich format (relative or absolute) the symbol address must be given</li>
<li>The symbol reference address : to know where in the section the symbol address must be written</li>
<li>The symbol definition address : to know where the computed symbol reference address must point</li>
</ol>
<p><img src="img/CoffLoader/HandsOn/RelocInfoToKnow.jpg" alt="Position on relocation information to find"></p>
<h4 id="relocation-type">Relocation type</h4>
<p>The relocation type can be easily retrieved in the <code>CoffReloc</code> structure.</p>
<h4 id="symbol-reference-address">Symbol reference address</h4>
<p>The symbol reference address represents the first byte in the section that must be rewritten with the symbol definition address.</p>
<p>It can be computed from the information contained in the current <code>CoffSection</code> and <code>CoffReloc</code> structure with the following formula:</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// int i : index of the currently processed section</span>
<span class="hljs-keyword">void</span> *symbolRefAddress = sectionAddressMemory[i] + coffReloc.virtualAddress
</code></pre>
<p>This address is the copy destination.</p>
<h4 id="symbol-definition-address">Symbol definition address</h4>
<p>That is where the fun begins. Indeed, depending on the relocation type and the symbol storage type this address is computed differently. </p>
<p>The relocation type gives indication of the address positioning type expected by the section <em>ie absolute or relative address</em>. The symbol storage type gives indication about how the symbol offset can be found.</p>
<p>In this part, the main relocation type will be studies. Other relocation type can be found in <code>COFF</code> files but they will mainly be used for debugging or could be easily transcribed from the indication written here.</p>
<h5 id="imagerelamd64addr64">IMAGE_REL_AMD64_ADDR64</h5>
<ul>
<li>Positioning : Absolute</li>
<li>Address size : 64bit</li>
<li>Complexity   : Easy</li>
</ul>
<p>Start with an easy one.
This relocation type indicates an absolute positioning. The symbol address computed is expected to directly point on the symbol address if the start point is the address <code>0x0</code>.</p>
<p>The <code>ADDR64</code> part of the relocation type shows that a 64bit address is expected by the section.</p>
<p>The symbol definition address can simply be computed with the following formula:</p>
<pre><code class="lang-c"><span class="hljs-comment">//pseudo code</span>
<span class="hljs-comment">// void *symbolOffset : the symbol offset in its definition section</span>
<span class="hljs-comment">// CoffSymbol *coffSymbol : the current symbol</span>

<span class="hljs-keyword">uint64_t</span> symbolDefAddress = (<span class="hljs-keyword">uint64_t</span>)symbolOffset + (<span class="hljs-keyword">uint64_t</span>)sectionAddressMemory[coffSymbol-&gt;sectionIndex];
</code></pre>
<p>The <code>symbolOffset</code> computation method will be seen later.</p>
<p>The value can then be copied at the address pointed by the symbol reference address computed earlier.</p>
<pre><code class="lang-c">CopyMemory(symbolRefAddress, &amp;symbolDefAddress, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>));
</code></pre>
<h5 id="imagerelamd64addr32nb">IMAGE_REL_AMD64_ADDR32NB</h5>
<ul>
<li>Positioning : Relative</li>
<li>Address size : 32bit</li>
<li>Complexity   : Medium</li>
</ul>
<p>A little bit trickier.</p>
<p>This relocation type indicates a relative positioning. The symbol address computed is expected to directly point on the symbol address if the start point is the previously computed symbol reference address.</p>
<p>Looking at the figure explaining the difference between absolute and relative address, this symbol definition can be computed with the following formula:</p>
<pre><code class="lang-c"><span class="hljs-comment">//pseudo code</span>
<span class="hljs-comment">// void *symbolOffset : the symbol offset in its definition section</span>
<span class="hljs-comment">// CoffSymbol *coffSymbol : the current symbol</span>

<span class="hljs-keyword">uint64_t</span> absoluteSymbolAddress = (<span class="hljs-keyword">uint64_t</span>)symbolOffset + (<span class="hljs-keyword">uint64_t</span>)sectionsAddress[coffSymbol-&gt;sectionNumber]
<span class="hljs-keyword">uint32_t</span> relativeSymbolDefAddress = (<span class="hljs-keyword">uint32_t</span>)(absoluteSymbolAddress - (symbolRefAddress + <span class="hljs-number">4</span>))
</code></pre>
<p>This value can then be copied at the address pointed by the symbol reference address computed earlier.</p>
<pre><code class="lang-c">CopyMemory(symbolRefAddress, &amp;relativeSymbolDefAddress, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>));
</code></pre>
<h5 id="imagerelamd64addrrel32x">IMAGE_REL_AMD64_ADDR_REL32_X</h5>
<ul>
<li>Positioning : Relative</li>
<li>Address size : 32bit</li>
<li>Complexity   : Medium</li>
</ul>
<p>Like the previous one, buuuuuuut not really.</p>
<p>There are 6 relocation type starting with <code>IMAGE_REL_AMD64_ADDR_REL32</code> :</p>
<ol>
<li>IMAGE_REL_AMD64_ADDR_REL32</li>
<li>IMAGE_REL_AMD64_ADDR_REL32_1</li>
<li>IMAGE_REL_AMD64_ADDR_REL32_2</li>
<li>IMAGE_REL_AMD64_ADDR_REL32_3</li>
<li>IMAGE_REL_AMD64_ADDR_REL32_4</li>
<li>IMAGE_REL_AMD64_ADDR_REL32_5</li>
</ol>
<p>All these relocation types can be handled with the same formula. The <code>_X</code> at the end of the name represents a little offset of <code>X</code> byte that must be subtracted to the relative symbol definition address computed.</p>
<p>All these relocation can be handled with the same generic formula:</p>
<pre><code class="lang-c"><span class="hljs-comment">//pseudo code</span>
<span class="hljs-comment">// void *symbolOffset : the symbol offset in its definition section</span>
<span class="hljs-comment">// CoffSymbol *coffSymbol : the current symbol</span>

<span class="hljs-keyword">uint64_t</span> absoluteSymbolAddress = (<span class="hljs-keyword">uint64_t</span>)symbolOffset + (<span class="hljs-keyword">uint64_t</span>)sectionsAddress[coffSymbol-&gt;sectionNumber]
<span class="hljs-keyword">uint32_t</span> relativeSymbolDefAddress = (<span class="hljs-keyword">uint32_t</span>)(absoluteSymbolAddress - (coffReloc-&gt;type - <span class="hljs-number">4</span>) - (symbolRefAddress + <span class="hljs-number">4</span>))
</code></pre>
<p>This value can then be copied at the address pointed by the symbol reference address computed earlier.</p>
<pre><code class="lang-c">CopyMemory(symbolRefAddress, &amp;relativeSymbolDefAddress, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>));
</code></pre>
<h4 id="compute-symbol-offset">Compute symbol offset</h4>
<p>As shown in the previous part, the symbol offset is a value needed to compute either absolute or relative symbol definition address. </p>
<p>Depending on the symbol&apos;s storage class, this offset can be computed in different ways.</p>
<h5 id="compute-standard-symbols-offset">Compute standard symbol&apos;s offset</h5>
<p>The standard way to retrieve the symbol offset is by looking at the last byte of the value pointed by the address stored in the relocation structure.</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// void **sectionAddressMemory : table that stores section allocated memory address</span>
<span class="hljs-keyword">uint32_t</span> symbolOffset = *(sectionAddressMemory[i] + coffReloc-&gt;virtualAddress)
</code></pre>
<h5 id="compute-static-and-external-symbols-offset">Compute STATIC and EXTERNAL symbol&apos;s offset</h5>
<p>The offset computation method is quite different for the symbols whose storage class is either <code>IMAGE_SYM_CLASS_STATIC</code> or <code>IMAGE_SYM_CLASS_EXTERNAL</code>.</p>
<p>Indeed, for the <code>IMAGE_SYM_CLASS_STATIC</code> symbols, the offset is contained in the <code>CoffSymbol</code> structure&apos;s <code>value</code> field if different than <code>0</code>. Otherwise, the computation method fallback to the default one explained in the previous part.</p>
<p>For the <code>IMAGE_SYM_CLASS_EXTERNAL</code> symbols, the offset is also contained in the <code>CoffSymbol</code> structure&apos;s <code>value</code> field if the symbol <code>sectionNumber</code> is not 0. Otherwise, the computation method fallback to the default one explained in the previous part.</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>

<span class="hljs-keyword">uint32_t</span> symbolOffset;
<span class="hljs-keyword">if</span> ((coffSymbol-&gt;storageClass == IMAGE_SYM_CLASS_STATIC &amp;&amp; coffSymbol-&gt;value != <span class="hljs-number">0</span>) || (coffSymbol-&gt;storageClass == IMAGE_SYM_CLASS_EXTERNAL &amp;&amp; coffSymbol-&gt;sectionNumber != <span class="hljs-number">0x0</span>)) {
    <span class="hljs-comment">// With static class symbol, the offset is given through the symbol-&gt;value (if not 0)</span>
    <span class="hljs-comment">// and not in the segment symbol address last bytee</span>
    symbolOffset = coffSymbol-&gt;value;
}
<span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// For standard symbol, the offset is given as the last byte of the</span>
    <span class="hljs-comment">// value pointed by the symbol reference address in the section.</span>
    CopyMemory(&amp;segmentOffset, symbolReferenceAddress, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>));
}
</code></pre>
<p>Yey ! It is now possible to compute all addresses needed to perform the symbol relocation.</p>
<h3 id="put-things-altogether">Put things altogether</h3>
<p>In order to perform all relocation, the different section must be parsed, their relocation table retrieved and applied. The following code can be used as a template:</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// void *data : the address of the first COFF byte</span>

CoffHeader *coffHeader = (coffHeader *)<span class="hljs-function">data
<span class="hljs-title">for</span><span class="hljs-params">(size_t i = <span class="hljs-number">0</span>; i &lt; coffHeader-&gt;numberOfSections; i++)</span></span>{
    <span class="hljs-comment">// parse all the sections</span>
    CoffSection *coffSection = data + HEADER_SIZE + SECTION_SIZE * i;

    <span class="hljs-comment">// parse all the relocations for the given section</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j &lt; coffSection-&gt;numberOfRelocations; j++){
        <span class="hljs-comment">// get the current relocation to process</span>
        CoffReloc *coffReloc = data + coffSection-&gt;pointerToRelocations + RELOC_SIZE * j;

        <span class="hljs-comment">// get the symbol related to the relocation</span>
        CoffSymbol *coffSymbol = data + coffHeader-&gt;pointerToSymbolTable + SYMBOL_SIZE * coffReloc-&gt;symbolTableIndex
        <span class="hljs-keyword">void</span> *symbolDefAddress;
        <span class="hljs-keyword">if</span>(isNonStandardSymbol(coffSymbol)){

            <span class="hljs-keyword">if</span>(isExternalFunctionSymbol(coffSymbol)){
                <span class="hljs-comment">// resolve the function</span>
                <span class="hljs-comment">// add the function address in the .got</span>
                <span class="hljs-comment">// return the got address pointing to the resolved function</span>
                symbolDefAddress = resolveAndAddToGot(coffSymbol);
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-comment">// create a new entry in the .bss</span>
                <span class="hljs-comment">// return the address pointing to the new entry in the .bss</span>
                symbolDefAddress = addBssEntry(coffSymbol);
            }
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-comment">// Compute the symbol absolute address</span>
            symbolDefAddress = getSymbolOffset(coffSymbol) + sectionsAddress[coffSymbol-&gt;sectionNumber]
        }

        <span class="hljs-comment">// Compute the address expected by the section </span>
        <span class="hljs-comment">// Write it in the section</span>
        processRelocation(coffSymbol, symbolDefAddress, coffReloc-&gt;type);
    }
}
</code></pre>
<p>So now all the sections can point to the right address and reach their symbols. The program can be run without trying to reach an undefined address such as <code>0x00000000</code>.</p>
<h2 id="run-the-code">Run the code</h2>
<p>Now all symbols are resolved, it is possible to run the code linked in memory. This can be done in three simple steps:</p>
<ol>
<li>Retrieve the symbol address related to the function to run (<em>the function <code>main(int argc, char **argv)</code> for example</em>)</li>
<li>Cast the address to a function prototype</li>
<li>Run the function</li>
</ol>
<p>This can be done with the following code:</p>
<pre><code class="lang-c"><span class="hljs-comment">//pseudo code</span>
<span class="hljs-comment">// void **sectionAddressMemory : table that stores section allocated memory address</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; coffHeader-&gt;numberOfSymbols; i++){
    CoffSymbol *coffSymbol = (CoffSymbol *)(data + coffHeader-&gt;pointerToSymbolTable + SYMBOL_SIZE * i);
    <span class="hljs-keyword">char</span> *symbolName = resoleSymbolName(coffSymbol);

    <span class="hljs-comment">// find the symbol related to the main function</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(symbolName, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>){

        <span class="hljs-comment">// define the function prototype</span>
        <span class="hljs-keyword">int</span>(* function)(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv);

        <span class="hljs-comment">// cast the symbol address into a function</span>
        function = <span class="hljs-keyword">int</span>(*)(<span class="hljs-keyword">int</span>, argv **)(sectionAddressMemory[coffSymbol-&gt;sectionIndex] + coffSymbol-&gt;value)

        <span class="hljs-comment">// run the function with its arguments</span>
        function(argc, argv);
    }
}
</code></pre>
<p>If all relocations have been successfully performed, the function should run smoothly ! </p>
<p>Yey ! Here is your <code>CoffLoader</code> ! </p>
<h1 id="upgrade">Upgrade</h1>
<h2 id="compatibility-with-cobaltstrike-bof">Compatibility with CobaltStrike BOF</h2>
<p>The current <code>COFFLoader</code> will be unable to run standard <code>CobaltStrike</code> <code>BOF</code>. Indeed, the <code>CobaltStrike</code> <code>BOF</code> use specific <code>API</code> that allows it to communicate with the beacon.</p>
<p>This communication is mandatory as <code>CobaltStrike</code> beacons need to be able to retrieve the <code>COFF</code> result to send it back to the operator.</p>
<h3 id="cobaltstrike-bof-specificities">CobaltStrike BOF specificities</h3>
<p>The <code>CobaltStrike</code> documentation shows several <code>API</code> that can be used in the <code>BOF</code> to communicate with the beacon.</p>
<p>The following functions can be used in the <code>BOF</code> code:</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Argument Parsing</td>
<td>BeaconDataParse</td>
<td>Initialize the BOF argument parser</td>
</tr>
<tr>
<td>Argument Parsing</td>
<td>BeaconDataInt</td>
<td>Extract int from arguments</td>
</tr>
<tr>
<td>Argument Parsing</td>
<td>BeaconDataShort</td>
<td>Extract short from arguments</td>
</tr>
<tr>
<td>Argument Parsing</td>
<td>BeaconDataLength</td>
<td>Get arguments string length</td>
</tr>
<tr>
<td>Argument Parsing</td>
<td>BeaconDataExtract</td>
<td>Extract string from arguments</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconFormatAlloc</td>
<td>Allocate memory to format large output</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconFormatReset</td>
<td>Resets format object to its default state</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconFormatFree</td>
<td>Free the format object</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconFormatAppend</td>
<td>Append data to the format object</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconFormatPrintf</td>
<td>Append formatted data to the the object</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconFormatToString</td>
<td>Return the object as a string</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconFormatInt</td>
<td>Append a 4bytes big endian integer to the object</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconPrintf</td>
<td>Format and send the output to the beacon</td>
</tr>
<tr>
<td>Response Formatting</td>
<td>BeaconOutput</td>
<td>Send output to the beacon</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>BeaconUseToken</td>
<td>Apply the specified token as Beacon&apos;s current thread token</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>BeaconRevertToken</td>
<td>Drop the current thread token</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>BeaconIsAdmin</td>
<td>Return true if the beacon is in high integrity</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>BeaconGetSpawnTo</td>
<td>Populate the specified buffer with the x86 or x64 spawnto value configured for this Beacon session</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>BeaconSpawnTemporaryProcess</td>
<td>Spawn en temporary process</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>BeaconInjectProcess</td>
<td>Inject payload in the specified process</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>BeaconInjectTemporaryProcess</td>
<td>This function will inject the specified payload into a temporary process that the BOF opted to launch through</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>BeaconCleanupProcess</td>
<td>Cleanup handles</td>
</tr>
<tr>
<td>Advanced Operation</td>
<td>toWideChar</td>
<td>Convert the src string to a UTF16-LE wide-character string, using the target&apos;s default encoding</td>
</tr>
</tbody>
</table>
<p>These <code>API</code> are not supported by the <code>CoffLoader</code> out of the box. They must be implemented in the <code>CoffLoader</code> code.</p>
<p><code>CobaltStrike</code> <a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/beacon.h" target="_blank">furnishes</a> a header file that can be used to compile <code>BOF</code>. This header file can be used as a base to rebuild the <code>API</code> that will be integrated in the <code>COFFLoader</code>.
<code>TrustedSec</code> starts to implement several of these <code>API</code> in <code>C</code>. The file can be found <a href="https://github.com/trustedsec/COFFLoader/blob/main/beacon_compatibility.c" target="_blank">here</a>.</p>
<p>Once these <code>API</code> are implemented, they must be accessible to the <code>COFF</code> file launched by the <code>COFFLoader</code>. Unlike functions available in shared libraries, it will not be possible to use <code>GetProcAddress</code> to resolve these functions.</p>
<h3 id="add-support-for-beacon-internal-functions">Add support for beacon internal functions</h3>
<p>In order to be able to resolve the <code>CobaltStrike API functions</code> symbols used in the <code>COFF</code>file, the easiest way is to collect all functions address in an array and use these addresses while resolving the symbols.</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>

<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> **internalFunctions = {
    {(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)<span class="hljs-string">&quot;BeaconDataParse&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)BeaconDataParse},
    {(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)<span class="hljs-string">&quot;BeaconDataInt&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)BeaconDataInt},
    {(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)<span class="hljs-string">&quot;BeaconDataShort&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*)BeaconDataShort},
};
</code></pre>
<p>Then, in the function used to resolve functions address it is possible to check whether the function to resolve is one of the internal functions or an function stored in shared librairies.</p>
<p>The internal function can be differentiated from shared libraries as their <code>DFR</code> name will not show any external library :</p>
<pre><code class="lang-c"><span class="hljs-function">DECLSPEC_IMPORT <span class="hljs-keyword">void</span>    <span class="hljs-title">BeaconDataParse</span><span class="hljs-params">(datap * parser, <span class="hljs-keyword">char</span> * buffer, <span class="hljs-keyword">int</span> size)</span></span>;
</code></pre>
<p>Thus, the generated symbol will not contain any shared library name to look at.</p>
<p>In this case, the <code>internalFunctions</code> array can simply be looped over while the function name is not found. Once the right entry is found, the address related to the function can be added to the <code>.got</code> section.</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// char *functionSymbolName : function symbol name in DFR resolution</span>

<span class="hljs-keyword">void</span> *functionAddress = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">char</span> **symbolSplitted = functionSymbolName.split(<span class="hljs-string">&apos;$&apos;</span>);
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(symbolSplitted[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>){
    <span class="hljs-comment">// The symbol represents an internal function</span>

    <span class="hljs-keyword">char</span> *functionName = symbolSplitted[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// loop through defined internal functions</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; internalFunctions.size(); i++){
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(functionName, internalFunctions[i][<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span>){

            <span class="hljs-comment">// retrieve the matching one</span>
            functionAddress = internalFunctions[i][<span class="hljs-number">1</span>];
        }
    }
}
<span class="hljs-keyword">else</span>{
    <span class="hljs-comment">// standard function resolution through GetProcAddress</span>
    <span class="hljs-keyword">char</span> *libraryName = symbolSplitted[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">char</span> *functionName = symbolSplitted[<span class="hljs-number">1</span>];
    functionAddress = GetProcAddress(GetModuleHandle(libraryName), functionName);
}

<span class="hljs-comment">// Fill up the .got with the new function address</span>
<span class="hljs-keyword">void</span> *nextFreeGotSlot = got + gotSize * <span class="hljs-number">0x08</span>;
CopyMemory(nextFreeGotSlot, &amp;functionAddress, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>));
gotSize += <span class="hljs-number">1</span>;
<span class="hljs-keyword">void</span> *absoluteSymbolAddress = nextFreeGotSlot;
</code></pre>
<p>The <code>COFF</code> will then be able to resolve internal functions symbols and communicate with the <code>COFFLoader</code> process for, as an example, returning execution results through the <code>BeaconPrintf</code> function.</p>
<p>This method can be applied to any function defined in the <code>COFFLoader</code> code.</p>
<h3 id="format-parameters-for-cobalstrike-bof">Format parameters for CobalStrike BOF</h3>
<p>The parameters given to <code>ColbaltStrike</code> <code>BOF</code> must be formatted in a given way. Indeed, the <code>BeaconAPI</code> used by <code>CobaltStrike</code> <code>BOF</code> expects the parameters to be formatted in a given way.</p>
<ul>
<li>All parameters must be given as a single string</li>
<li>String parameters are expected to be a length prefixed binary blob</li>
<li>Number parameters are not length prefixed (as their type define their length)</li>
<li>The whole parameter string is expected to be a length prefixed binary blob</li>
<li>Length prefixes are a 4-byte values</li>
</ul>
<p>Thus, if your <code>BOF</code> expects two parameters (one string and one integer), they must be sent as follows :</p>
<pre><code class="lang-c"><span class="hljs-comment">// each length is in bytes : length(&quot;hello world&quot;) = strlen(&quot;hello world&quot;) * sizeof(char)</span>
${totalLength}${stringArgumentLength}${stringArgument}${intArgument}
</code></pre>
<p>The following <code>C</code> code can be used to format a list of parameters as a <code>CobaltStrike</code> parameter string:</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _Arg {
    <span class="hljs-keyword">void</span>* value;         <span class="hljs-comment">// the useful argument value</span>
    <span class="hljs-keyword">size_t</span> size;        <span class="hljs-comment">// the size in byte of the value</span>
    BOOL includeSize;   <span class="hljs-comment">// is the value must be given as length-prefixed</span>
} Arg;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PackData</span><span class="hljs-params">(Arg* args, size_t numberOfArgs, <span class="hljs-keyword">char</span>** output, size_t* size)</span> </span>{
    <span class="hljs-keyword">uint32_t</span> fullSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numberOfArgs; i++) {
        Arg arg = args[i];
        fullSize += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>) + arg.size;
    }
    *output = (<span class="hljs-keyword">void</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>) + fullSize);
    fullSize = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numberOfArgs; i++) {
        Arg arg = args[i];
        <span class="hljs-keyword">if</span> (arg.includeSize == TRUE) {
            <span class="hljs-built_in">memcpy</span>(*output + fullSize, &amp;arg.size, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>));
            fullSize += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>);
        }
        <span class="hljs-built_in">memcpy</span>(*output + fullSize, arg.value, arg.size);
        fullSize += arg.size;
    }
    <span class="hljs-built_in">memcpy</span>(*output, &amp;fullSize, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>));
    *size = fullSize;
}
</code></pre>
<h2 id="dynamic-got-and-bss">Dynamic .got and .bss</h2>
<p>The <code>VirtualAlloc</code> call used to allocate the <code>.got</code> and <code>.bss</code> section uses a static predefined size of <code>1024</code> bytes. If there are more than <code>1024</code> bytes of function pointers or initialized data that must be defined during the symbol resolution, the <code>CoffLoader</code> will crash during the <code>COFF</code> linking time. Indeed, it will try to write symbol data in un-allocated memory in the <code>.bss</code> or the <code>.got</code>.</p>
<p>To avoid using fixed size <code>.got</code> and <code>.bss</code> sections, it is possible to pre-calculate their sizes by looking at all the symbols before allocating the memory.</p>
<p>This method is quite effective but it will ask the <code>CoffLoader</code> to enumerate and resolve twice the symbols : a first one to calculate the section size, the second one to resolve and relocate the symbols.
To avoid this unnecessary double lookup, it is possible to save the resolved symbols during the first processing and then reuse the values for the relocation.</p>
<p>The following structures can be used to save the pre-resolved symbols:</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _BssEntry {
    <span class="hljs-keyword">void</span>* symbol;            <span class="hljs-comment">// address of the current processed symbol</span>
    <span class="hljs-keyword">uint64_t</span> bssOffset;        <span class="hljs-comment">// offset of the resolved symbol in the .bss</span>
} BssEntry;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _GotEntry {
    <span class="hljs-keyword">void</span>* symbol;            <span class="hljs-comment">// address of the current processed symbol</span>
    <span class="hljs-keyword">void</span>* function;            <span class="hljs-comment">// address of the resolved function (GetProcAddress or internal function)</span>
    <span class="hljs-keyword">uint64_t</span> gotOffset;     <span class="hljs-comment">// offset of the resolved symbol in the got</span>
} GotEntry;
</code></pre>
<p>These structures are filled up before the <code>.got</code> and <code>.bss</code> section allocation:</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>

<span class="hljs-keyword">size_t</span> bssOffset = <span class="hljs-number">0</span>;
<span class="hljs-keyword">size_t</span> gotSize = <span class="hljs-number">0</span>;
<span class="hljs-comment">// loop over each symbols</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; coffHeader-&gt;numberOfSymbols; i++) {

    <span class="hljs-comment">// get the current symbol</span>
    CoffSymbol* coffSymbol = (CoffSymbol*)((<span class="hljs-keyword">uint64_t</span>)symbols + (<span class="hljs-keyword">uint64_t</span>)i * SYMBOL_SIZE);

    <span class="hljs-keyword">if</span>(isUninitializedVariable(coffSymbol)){
        <span class="hljs-comment">// save the symbol information</span>
        bssSymbols.append({
            .symbol = coffSymbol,
            .bssOffset = bssOffset
        });

        <span class="hljs-comment">// extend the futur .bss section size</span>
        bssOffset += coffSymbol-&gt;value;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(isExternalFunction(coffSymbol)){

        <span class="hljs-comment">// get the external function address through GetProcAddress </span>
        <span class="hljs-comment">// or in the internalFunctions array</span>
        <span class="hljs-keyword">void</span> *functionAddress = resolveExternalFunction(coffSymbol);

        <span class="hljs-comment">// save the symbol information</span>
        gotSymbols.append({
            .symbol = symbol,
            .function = functionAddress,
            .gotOffset = gotOffset
        });

        <span class="hljs-comment">// extend the futur .got section size</span>
        gotOffset += <span class="hljs-number">0x08</span>;
    }
}

<span class="hljs-comment">// allocate the sections with the right size</span>
<span class="hljs-keyword">void</span> *got = VirtualAlloc(gotSize);
<span class="hljs-keyword">void</span> *bss = VirtualAlloc(bssSize);
</code></pre>
<p>Then, when relocation must be performed, these structures can be looked up to retrieve the pre-assigned offset in the <code>.bss</code> or <code>.got</code> and use these values as the absolute symbol definition address without re-resolving the symbol.</p>
<pre><code class="lang-c"><span class="hljs-comment">// pseudo code</span>
<span class="hljs-comment">// changes of the code used to perfom the relocation</span>
[...]

<span class="hljs-keyword">if</span>(isNonStandardSymbol(coffSymbol)){

    <span class="hljs-keyword">if</span>(isExternalFunctionSymbol(coffSymbol)){

        <span class="hljs-comment">// loop through the pre-resolved symbols</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; gotSymbols.size(); i++){

            <span class="hljs-comment">// if a symbol is found, reuse the information without additional computing</span>
            <span class="hljs-keyword">if</span>(coffSymbol == gotSymbols[i].symbol){
                symbolDefAddress = got + gotSymbols[i].gotOffset;
                CopyMemory(symbolDefAddress, gotSymbols[i].functionAddress)
                <span class="hljs-keyword">break</span>;
            }
        }
    }
    <span class="hljs-keyword">else</span>{

        <span class="hljs-comment">// loop through the pre-resolved symbols</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; bssSymbols.size(); i++){

            <span class="hljs-comment">// if a symbol is found, reuse the information without additional computing</span>
            <span class="hljs-keyword">if</span>(coffSymbol == bssSymbols[i].symbol){
                symbolDefAddress = bss + bssSymbols[i].bssOffset;
                <span class="hljs-keyword">break</span>;
            }
        }
    }
}

[...]
</code></pre>
<p>So now, your <code>CoffLoader</code> is able to process <code>COFF</code> files with undefined number of external functions and initialized variables.</p>
<p>And as usual, <em>Yey !</em></p>
<h1 id="conclusion">Conclusion</h1>
<p>That was a long journey. After writing all of this, it looks like nothing is really complicated and I&apos;m beginning to ask myself why it needs any explanation.</p>
<p>The design of a <code>CoffLoader</code> does not contain any complex concept. Everything is simple and quite obvious once the <code>COFF</code> specification is well understood...</p>
<p>So now, you should, too, think that the subject is simple and the loader can be easily implemented. I hope it is the case.</p>
<p>At the end of this article, you should understand how <code>PE</code> specification work and how to easily programmatically navigate through all this information. The <code>PE</code> format has not been seen in depth and several interesting parts are missing from this article (such as the PEB and all the secrets it contains) but it was not really the goal of the article.</p>
<p>However, you should master the <code>COFF</code> specification for <code>Windows Object</code>. You should be able to easily find all the information you need in these files as well as being able to map them in memory. Likewise, the principle of relocation should not have any secret for you anymore. When someone will ask you <em>why the hell my <code>PE</code> is performing relocation</em> or <em>why my linker tells me it cannot find the XXXX symbol</em> you should be able to explain it to him, in more details he wanted, why his code sucks.</p>
<p>All of these theoretical knowledge should have helped you to develop the <code>CoffLoader</code> in its most advanced shape in order to run <code>CobaltStrike</code> <code>BOF</code> without needing to pay for the <code>CobaltStrike</code> license. Likewise, if you use <code>CobaltStrike</code> and do not need to implement any <code>CoffLoader</code>, this article should have been quite an interesting lecture as now you know exactly how all of it works and even gave you some basis to <a href="https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/" target="_blank">start writing your own BOF files</a>.</p>
<p>In a personal point of view, I found the journey interesting and it helped me to deeply understand how <code>Windows PE</code> works and how the <code>Object Files</code> can be used to generate <code>Windows</code> binaries. I hope you liked this article and do not think it was a complete waste of time.</p>
<h1 id="ressources">Ressources</h1>
<ul>
<li><a href="https://www.trustedsec.com/blog/coffloader-building-your-own-in-memory-loader-or-how-to-run-bofs/" target="_blank">https://www.trustedsec.com/blog/coffloader-building-your-own-in-memory-loader-or-how-to-run-bofs/</a></li>
<li><a href="https://blog.katastros.com/a?ID=00100-b060e132-0540-4c53-8527-bf45b2964215" target="_blank">https://blog.katastros.com/a?ID=00100-b060e132-0540-4c53-8527-bf45b2964215</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Docs/Passing arguments.html" class="navigation navigation-prev " aria-label="Previous page: Passing Arguments">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Elastic EDR.html" class="navigation navigation-next " aria-label="Next page: Elastic EDR">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"COFF Loader","level":"3.1.2","depth":2,"next":{"title":"Elastic EDR","level":"3.1.3","depth":2,"path":"Malware/Elastic EDR.md","ref":"Malware/Elastic EDR.md","articles":[]},"previous":{"title":"Passing Arguments","level":"3.1.1.4","depth":3,"path":"Malware/Docs/Passing arguments.md","ref":"Malware/Docs/Passing arguments.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["-sharing","collapsible-chapters@git+https://gitlab.dqr/gitbook-plugin/collapsible-chapters.git#main","copy-code-button@git+https://gitlab.dqr/gitbook-plugin/copy-code-button.git#main","hide-published-with","search-plus","simple-page-toc"],"pluginsConfig":{"github":{"url":"https://github.com/YoannDqr"},"simple-page-toc":{"maxDepth":3,"skipFirstH1":true},"search":{},"collapsible-chapters":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"hide-published-with":{},"fontsettings":{"theme":"white","family":"sans","size":2},"twitter":{"url":"https://twitter.com/HackerOtter"},"highlight":{},"copy-code-button":{},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"search-plus":{}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Malware/CoffLoader.md","mtime":"2022-08-19T09:56:59.119Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-09-23T14:20:02.235Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-collapsible-chapters/collapsible-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-hide-published-with/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

